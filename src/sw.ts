/// <reference lib="webworker" />
/// <reference lib="es2017" />

import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import type { PrecacheEntry } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { BackgroundSyncPlugin } from 'workbox-background-sync';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { clientsClaim } from 'workbox-core';

declare const self: ServiceWorkerGlobalScope;

// Declare service worker global scope with Workbox manifest
declare global {
  interface ServiceWorkerGlobalScope {
    __WB_MANIFEST: Array<string | PrecacheEntry>;
  }
}

// Take control immediately
clientsClaim();

// Precache all assets generated by Astro
precacheAndRoute(self.__WB_MANIFEST);

// Handle navigation routes with network-first strategy
const navigationRoute = new NavigationRoute(createHandlerBoundToURL('/index.html'), {
  allowlist: [/^\/$/],
  denylist: [/\.[^.]+$/], // Exclude URLs with file extensions
});
registerRoute(navigationRoute);

// Background sync for form submissions
const bgSyncPlugin = new BackgroundSyncPlugin('form-submissions', {
  maxRetentionTime: 24 * 60, // 24 hours in minutes
});

// Handle form submissions with background sync
registerRoute(
  /\/api\/submit-form/,
  new NetworkFirst({
    plugins: [bgSyncPlugin],
  }),
  'POST'
);

// Push notification event handler
self.addEventListener('push', ((event: PushEvent) => {
  const data = event.data?.json() ?? {};
  const options: NotificationOptions = {
    body: data.body || 'New content available!',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    data: {
      url: data.url || '/',
    },
  };

  event.waitUntil(self.registration.showNotification(data.title || 'Tech AI Blog Update', options));
}) as EventListener);

// Notification click handler
self.addEventListener('notificationclick', ((event: NotificationEvent) => {
  event.notification.close();

  event.waitUntil(
    self.clients
      .matchAll({ type: 'window', includeUncontrolled: true })
      .then((windowClients: readonly WindowClient[]) => {
        const url = event.notification.data?.url || '/';

        // If a window is already open, focus it
        for (const client of windowClients) {
          if (client.url === url && 'focus' in client) {
            return client.focus();
          }
        }

        // Otherwise, open a new window
        return self.clients.openWindow(url);
      })
  );
}) as EventListener);

// Define types for periodic sync
interface ExtendableSyncEvent extends ExtendableEvent {
  tag: string;
}

// Periodic background sync for content updates
if ('periodicSync' in self.registration) {
  const SYNC_TAG = 'content-sync';

  self.addEventListener('periodicsync', ((event: ExtendableSyncEvent) => {
    if (event.tag === SYNC_TAG) {
      event.waitUntil(updateContent());
    }
  }) as EventListener);

  // Function to update content
  async function updateContent() {
    try {
      const cache = await caches.open('content-cache');
      await cache.add('/api/latest-content');
    } catch (error) {
      console.error('Failed to update content:', error);
    }
  }
}
